<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>flexynesis.main API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>flexynesis.main</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import torch 
from torch.utils.data import DataLoader, random_split

import pytorch_lightning as pl
from pytorch_lightning.callbacks import RichProgressBar
from pytorch_lightning.callbacks.progress.rich_progress import RichProgressBarTheme
from pytorch_lightning.callbacks import EarlyStopping

from tqdm import tqdm

from skopt import Optimizer
from skopt.utils import use_named_args
from .config import search_spaces

import numpy as np

import os, yaml
from skopt.space import Integer, Categorical, Real

            
class HyperparameterTuning:
    &#34;&#34;&#34;
    Hyperparameter Tuning class for optimizing model parameters.

    This class provides functionalities to perform hyperparameter tuning using Bayesian optimization.
    It supports various features like live loss plotting, early stopping, and custom configuration loading.

    Attributes:
        dataset: Dataset used for training and validation.
        model_class: The class of the model to be tuned.
        target_variables: List of target variables for the model.
        batch_variables: List of batch variables, if applicable.
        config_name: Name of the configuration for tuning parameters.
        n_iter: Number of iterations for the tuning process.
        plot_losses: Boolean flag to plot losses during training.
        val_size: Validation set size as a fraction of the dataset.
        use_loss_weighting: Flag to use loss weighting during training.
        early_stop_patience: Number of epochs to wait for improvement before stopping.
    
    Methods:
        objective(params, current_step, total_steps): Evaluates a set of parameters.
        perform_tuning(): Executes the hyperparameter tuning process.
        init_early_stopping(): Initializes early stopping mechanism.
        load_and_convert_config(config_path): Loads and converts a configuration file.
    &#34;&#34;&#34;
    def __init__(self, dataset, model_class, config_name, target_variables, 
                 batch_variables = None, n_iter = 10, config_path = None, plot_losses = False,
                 val_size = 0.2, use_loss_weighting = True, early_stop_patience = -1):
        self.dataset = dataset
        self.model_class = model_class
        self.target_variables = target_variables.strip().split(&#39;,&#39;)
        self.batch_variables = batch_variables.strip().split(&#39;,&#39;) if batch_variables is not None else None
        self.config_name = config_name
        self.n_iter = n_iter
        self.plot_losses = plot_losses # Whether to show live loss plots (useful in interactive mode)
        self.val_size = val_size
        self.progress_bar = RichProgressBar(
                                theme = RichProgressBarTheme(
                                    progress_bar = &#39;green1&#39;,
                                    metrics = &#39;yellow&#39;, time=&#39;gray&#39;,
                                    progress_bar_finished=&#39;red&#39;))
        self.early_stop_patience = early_stop_patience
        self.use_loss_weighting = use_loss_weighting
        
        # If config_path is provided, use it
        if config_path:
            external_config = self.load_and_convert_config(config_path)
            if self.config_name in external_config:
                self.space = external_config[self.config_name]
            else:
                raise ValueError(f&#34;&#39;{self.config_name}&#39; not found in the provided config file.&#34;)
        else:
            if self.config_name in search_spaces:
                self.space = search_spaces[self.config_name]
            else:
                raise ValueError(f&#34;&#39;{self.config_name}&#39; not found in the default config.&#34;)

    def objective(self, params, current_step, total_steps):
        model = self.model_class(params, self.dataset, self.target_variables, 
                                 self.batch_variables, self.val_size, self.use_loss_weighting)
        print(params)
        
        mycallbacks = [self.progress_bar]
        # for interactive usage, only show loss plots 
        if self.plot_losses:
            mycallbacks = [LiveLossPlot(hyperparams=params, current_step=current_step, total_steps=total_steps)]
        
        if self.early_stop_patience &gt; 0:
            mycallbacks.append(self.init_early_stopping())
            
        trainer = pl.Trainer(max_epochs=int(params[&#39;epochs&#39;]), log_every_n_steps=5, 
                            callbacks = mycallbacks, default_root_dir=&#34;./&#34;, logger=False, enable_checkpointing=False) 
        try:
            # Train the model
            trainer.fit(model)
            # Validate the model
            val_loss = trainer.validate(model)[0][&#39;val_loss&#39;]
        except ValueError as e:
            print(str(e))
            val_loss = float(&#39;inf&#39;)  # or some other value indicating failure
        return val_loss, model    
    
    def perform_tuning(self):
        opt = Optimizer(dimensions=self.space, n_initial_points=10, acq_func=&#34;gp_hedge&#34;, acq_optimizer=&#34;auto&#34;)

        best_loss = np.inf
        best_params = None
        best_model = None 

        with tqdm(total=self.n_iter, desc=&#39;Tuning Progress&#39;) as pbar:
            for i in range(self.n_iter):
                suggested_params_list = opt.ask()
                suggested_params_dict = {param.name: value for param, value in zip(self.space, suggested_params_list)}
                loss, model = self.objective(suggested_params_dict, current_step=i+1, total_steps=self.n_iter)
                opt.tell(suggested_params_list, loss)

                if loss &lt; best_loss:
                    best_loss = loss
                    best_params = suggested_params_list
                    best_model = model

                # Print result of each iteration
                pbar.set_postfix({&#39;Iteration&#39;: i+1, &#39;Best Loss&#39;: best_loss})
                pbar.update(1)
        # convert best params to dict 
        best_params_dict = {param.name: value for param, value in zip(self.space, best_params)}
        return best_model, best_params_dict
    
    def init_early_stopping(self):
        &#34;&#34;&#34;Initialize the early stopping callback.&#34;&#34;&#34;
        return EarlyStopping(
            monitor=&#39;val_loss&#39;,
            patience=self.early_stop_patience,
            verbose=True,
            mode=&#39;min&#39;
        )

    def load_and_convert_config(self, config_path):
        # Ensure the config file exists
        if not os.path.isfile(config_path):
            raise ValueError(f&#34;Config file &#39;{config_path}&#39; doesn&#39;t exist.&#34;)

        # Read the config file
        if config_path.endswith(&#39;.yaml&#39;) or config_path.endswith(&#39;.yml&#39;):
            with open(config_path, &#39;r&#39;) as file:
                loaded_config = yaml.safe_load(file)
        else:
            raise ValueError(&#34;Unsupported file format. Use .yaml or .yml&#34;)

        # Convert to skopt space
        search_space_user = {}
        for model, space_definition in loaded_config.items():
            space = []
            for entry in space_definition:
                entry_type = entry.pop(&#34;type&#34;)
                if entry_type == &#34;Integer&#34;:
                    space.append(Integer(**entry))
                elif entry_type == &#34;Real&#34;:
                    space.append(Real(**entry))
                elif entry_type == &#34;Categorical&#34;:
                    space.append(Categorical(**entry))
                else:
                    raise ValueError(f&#34;Unknown space type: {entry_type}&#34;)
            search_space_user[model] = space
        return search_space_user


import matplotlib.pyplot as plt
from IPython.display import clear_output
from pytorch_lightning import Callback

class LiveLossPlot(Callback):
    &#34;&#34;&#34;
    A callback for visualizing training loss in real-time during hyperparameter optimization.

    This class is a PyTorch Lightning callback that plots training loss and other metrics live as the model trains.
    It is especially useful for tracking the progress of hyperparameter optimization (HPO) steps.

    Attributes:
        hyperparams (dict): Hyperparameters being used in the current HPO step.
        current_step (int): The current step number in the HPO process.
        total_steps (int): The total number of steps in the HPO process.
        figsize (tuple): Size of the figure used for plotting.

    Methods:
        on_train_start(trainer, pl_module): Initializes the loss tracking at the start of training.
        on_train_end(trainer, pl_module): Actions to perform at the end of training.
        on_train_epoch_end(trainer, pl_module): Updates and plots the loss after each training epoch.
        plot_losses(): Renders the loss plot with the current training metrics.
    &#34;&#34;&#34;
    def __init__(self, hyperparams, current_step, total_steps, figsize=(10, 8)):
        super().__init__()
        self.hyperparams = hyperparams
        self.current_step = current_step
        self.total_steps = total_steps
        self.figsize = figsize

    def on_train_start(self, trainer, pl_module):
        self.losses = {}

    def on_train_end(self, trainer, pl_module):
        plt.ioff()

    def on_train_epoch_end(self, trainer, pl_module):
        for key, value in trainer.callback_metrics.items():
            if key not in self.losses:
                self.losses[key] = []
            self.losses[key].append(value.item())
        self.plot_losses()

    def plot_losses(self):
        clear_output(wait=True)
        plt.figure(figsize=self.figsize)
        for key, losses in self.losses.items():
            plt.plot(losses, label=key)
        
        hyperparams_str = &#39;, &#39;.join(f&#34;{key}={value}&#34; for key, value in self.hyperparams.items())
        title = f&#34;HPO Step={self.current_step} out of {self.total_steps}\n({hyperparams_str})&#34;
        
        plt.title(title)
        plt.xlabel(&#34;Epoch&#34;)
        plt.ylabel(&#34;Loss&#34;)
        plt.legend()
        plt.tight_layout()  # Adjust layout so everything fits
        plt.show()</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="flexynesis.main.HyperparameterTuning"><code class="flex name class">
<span>class <span class="ident">HyperparameterTuning</span></span>
<span>(</span><span>dataset, model_class, config_name, target_variables, batch_variables=None, n_iter=10, config_path=None, plot_losses=False, val_size=0.2, use_loss_weighting=True, early_stop_patience=-1)</span>
</code></dt>
<dd>
<div class="desc"><p>Hyperparameter Tuning class for optimizing model parameters.</p>
<p>This class provides functionalities to perform hyperparameter tuning using Bayesian optimization.
It supports various features like live loss plotting, early stopping, and custom configuration loading.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>dataset</code></strong></dt>
<dd>Dataset used for training and validation.</dd>
<dt><strong><code>model_class</code></strong></dt>
<dd>The class of the model to be tuned.</dd>
<dt><strong><code>target_variables</code></strong></dt>
<dd>List of target variables for the model.</dd>
<dt><strong><code>batch_variables</code></strong></dt>
<dd>List of batch variables, if applicable.</dd>
<dt><strong><code>config_name</code></strong></dt>
<dd>Name of the configuration for tuning parameters.</dd>
<dt><strong><code>n_iter</code></strong></dt>
<dd>Number of iterations for the tuning process.</dd>
<dt><strong><code>plot_losses</code></strong></dt>
<dd>Boolean flag to plot losses during training.</dd>
<dt><strong><code>val_size</code></strong></dt>
<dd>Validation set size as a fraction of the dataset.</dd>
<dt><strong><code>use_loss_weighting</code></strong></dt>
<dd>Flag to use loss weighting during training.</dd>
<dt><strong><code>early_stop_patience</code></strong></dt>
<dd>Number of epochs to wait for improvement before stopping.</dd>
</dl>
<h2 id="methods">Methods</h2>
<p>objective(params, current_step, total_steps): Evaluates a set of parameters.
perform_tuning(): Executes the hyperparameter tuning process.
init_early_stopping(): Initializes early stopping mechanism.
load_and_convert_config(config_path): Loads and converts a configuration file.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class HyperparameterTuning:
    &#34;&#34;&#34;
    Hyperparameter Tuning class for optimizing model parameters.

    This class provides functionalities to perform hyperparameter tuning using Bayesian optimization.
    It supports various features like live loss plotting, early stopping, and custom configuration loading.

    Attributes:
        dataset: Dataset used for training and validation.
        model_class: The class of the model to be tuned.
        target_variables: List of target variables for the model.
        batch_variables: List of batch variables, if applicable.
        config_name: Name of the configuration for tuning parameters.
        n_iter: Number of iterations for the tuning process.
        plot_losses: Boolean flag to plot losses during training.
        val_size: Validation set size as a fraction of the dataset.
        use_loss_weighting: Flag to use loss weighting during training.
        early_stop_patience: Number of epochs to wait for improvement before stopping.
    
    Methods:
        objective(params, current_step, total_steps): Evaluates a set of parameters.
        perform_tuning(): Executes the hyperparameter tuning process.
        init_early_stopping(): Initializes early stopping mechanism.
        load_and_convert_config(config_path): Loads and converts a configuration file.
    &#34;&#34;&#34;
    def __init__(self, dataset, model_class, config_name, target_variables, 
                 batch_variables = None, n_iter = 10, config_path = None, plot_losses = False,
                 val_size = 0.2, use_loss_weighting = True, early_stop_patience = -1):
        self.dataset = dataset
        self.model_class = model_class
        self.target_variables = target_variables.strip().split(&#39;,&#39;)
        self.batch_variables = batch_variables.strip().split(&#39;,&#39;) if batch_variables is not None else None
        self.config_name = config_name
        self.n_iter = n_iter
        self.plot_losses = plot_losses # Whether to show live loss plots (useful in interactive mode)
        self.val_size = val_size
        self.progress_bar = RichProgressBar(
                                theme = RichProgressBarTheme(
                                    progress_bar = &#39;green1&#39;,
                                    metrics = &#39;yellow&#39;, time=&#39;gray&#39;,
                                    progress_bar_finished=&#39;red&#39;))
        self.early_stop_patience = early_stop_patience
        self.use_loss_weighting = use_loss_weighting
        
        # If config_path is provided, use it
        if config_path:
            external_config = self.load_and_convert_config(config_path)
            if self.config_name in external_config:
                self.space = external_config[self.config_name]
            else:
                raise ValueError(f&#34;&#39;{self.config_name}&#39; not found in the provided config file.&#34;)
        else:
            if self.config_name in search_spaces:
                self.space = search_spaces[self.config_name]
            else:
                raise ValueError(f&#34;&#39;{self.config_name}&#39; not found in the default config.&#34;)

    def objective(self, params, current_step, total_steps):
        model = self.model_class(params, self.dataset, self.target_variables, 
                                 self.batch_variables, self.val_size, self.use_loss_weighting)
        print(params)
        
        mycallbacks = [self.progress_bar]
        # for interactive usage, only show loss plots 
        if self.plot_losses:
            mycallbacks = [LiveLossPlot(hyperparams=params, current_step=current_step, total_steps=total_steps)]
        
        if self.early_stop_patience &gt; 0:
            mycallbacks.append(self.init_early_stopping())
            
        trainer = pl.Trainer(max_epochs=int(params[&#39;epochs&#39;]), log_every_n_steps=5, 
                            callbacks = mycallbacks, default_root_dir=&#34;./&#34;, logger=False, enable_checkpointing=False) 
        try:
            # Train the model
            trainer.fit(model)
            # Validate the model
            val_loss = trainer.validate(model)[0][&#39;val_loss&#39;]
        except ValueError as e:
            print(str(e))
            val_loss = float(&#39;inf&#39;)  # or some other value indicating failure
        return val_loss, model    
    
    def perform_tuning(self):
        opt = Optimizer(dimensions=self.space, n_initial_points=10, acq_func=&#34;gp_hedge&#34;, acq_optimizer=&#34;auto&#34;)

        best_loss = np.inf
        best_params = None
        best_model = None 

        with tqdm(total=self.n_iter, desc=&#39;Tuning Progress&#39;) as pbar:
            for i in range(self.n_iter):
                suggested_params_list = opt.ask()
                suggested_params_dict = {param.name: value for param, value in zip(self.space, suggested_params_list)}
                loss, model = self.objective(suggested_params_dict, current_step=i+1, total_steps=self.n_iter)
                opt.tell(suggested_params_list, loss)

                if loss &lt; best_loss:
                    best_loss = loss
                    best_params = suggested_params_list
                    best_model = model

                # Print result of each iteration
                pbar.set_postfix({&#39;Iteration&#39;: i+1, &#39;Best Loss&#39;: best_loss})
                pbar.update(1)
        # convert best params to dict 
        best_params_dict = {param.name: value for param, value in zip(self.space, best_params)}
        return best_model, best_params_dict
    
    def init_early_stopping(self):
        &#34;&#34;&#34;Initialize the early stopping callback.&#34;&#34;&#34;
        return EarlyStopping(
            monitor=&#39;val_loss&#39;,
            patience=self.early_stop_patience,
            verbose=True,
            mode=&#39;min&#39;
        )

    def load_and_convert_config(self, config_path):
        # Ensure the config file exists
        if not os.path.isfile(config_path):
            raise ValueError(f&#34;Config file &#39;{config_path}&#39; doesn&#39;t exist.&#34;)

        # Read the config file
        if config_path.endswith(&#39;.yaml&#39;) or config_path.endswith(&#39;.yml&#39;):
            with open(config_path, &#39;r&#39;) as file:
                loaded_config = yaml.safe_load(file)
        else:
            raise ValueError(&#34;Unsupported file format. Use .yaml or .yml&#34;)

        # Convert to skopt space
        search_space_user = {}
        for model, space_definition in loaded_config.items():
            space = []
            for entry in space_definition:
                entry_type = entry.pop(&#34;type&#34;)
                if entry_type == &#34;Integer&#34;:
                    space.append(Integer(**entry))
                elif entry_type == &#34;Real&#34;:
                    space.append(Real(**entry))
                elif entry_type == &#34;Categorical&#34;:
                    space.append(Categorical(**entry))
                else:
                    raise ValueError(f&#34;Unknown space type: {entry_type}&#34;)
            search_space_user[model] = space
        return search_space_user</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="flexynesis.main.HyperparameterTuning.init_early_stopping"><code class="name flex">
<span>def <span class="ident">init_early_stopping</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Initialize the early stopping callback.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def init_early_stopping(self):
    &#34;&#34;&#34;Initialize the early stopping callback.&#34;&#34;&#34;
    return EarlyStopping(
        monitor=&#39;val_loss&#39;,
        patience=self.early_stop_patience,
        verbose=True,
        mode=&#39;min&#39;
    )</code></pre>
</details>
</dd>
<dt id="flexynesis.main.HyperparameterTuning.load_and_convert_config"><code class="name flex">
<span>def <span class="ident">load_and_convert_config</span></span>(<span>self, config_path)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def load_and_convert_config(self, config_path):
    # Ensure the config file exists
    if not os.path.isfile(config_path):
        raise ValueError(f&#34;Config file &#39;{config_path}&#39; doesn&#39;t exist.&#34;)

    # Read the config file
    if config_path.endswith(&#39;.yaml&#39;) or config_path.endswith(&#39;.yml&#39;):
        with open(config_path, &#39;r&#39;) as file:
            loaded_config = yaml.safe_load(file)
    else:
        raise ValueError(&#34;Unsupported file format. Use .yaml or .yml&#34;)

    # Convert to skopt space
    search_space_user = {}
    for model, space_definition in loaded_config.items():
        space = []
        for entry in space_definition:
            entry_type = entry.pop(&#34;type&#34;)
            if entry_type == &#34;Integer&#34;:
                space.append(Integer(**entry))
            elif entry_type == &#34;Real&#34;:
                space.append(Real(**entry))
            elif entry_type == &#34;Categorical&#34;:
                space.append(Categorical(**entry))
            else:
                raise ValueError(f&#34;Unknown space type: {entry_type}&#34;)
        search_space_user[model] = space
    return search_space_user</code></pre>
</details>
</dd>
<dt id="flexynesis.main.HyperparameterTuning.objective"><code class="name flex">
<span>def <span class="ident">objective</span></span>(<span>self, params, current_step, total_steps)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def objective(self, params, current_step, total_steps):
    model = self.model_class(params, self.dataset, self.target_variables, 
                             self.batch_variables, self.val_size, self.use_loss_weighting)
    print(params)
    
    mycallbacks = [self.progress_bar]
    # for interactive usage, only show loss plots 
    if self.plot_losses:
        mycallbacks = [LiveLossPlot(hyperparams=params, current_step=current_step, total_steps=total_steps)]
    
    if self.early_stop_patience &gt; 0:
        mycallbacks.append(self.init_early_stopping())
        
    trainer = pl.Trainer(max_epochs=int(params[&#39;epochs&#39;]), log_every_n_steps=5, 
                        callbacks = mycallbacks, default_root_dir=&#34;./&#34;, logger=False, enable_checkpointing=False) 
    try:
        # Train the model
        trainer.fit(model)
        # Validate the model
        val_loss = trainer.validate(model)[0][&#39;val_loss&#39;]
    except ValueError as e:
        print(str(e))
        val_loss = float(&#39;inf&#39;)  # or some other value indicating failure
    return val_loss, model    </code></pre>
</details>
</dd>
<dt id="flexynesis.main.HyperparameterTuning.perform_tuning"><code class="name flex">
<span>def <span class="ident">perform_tuning</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def perform_tuning(self):
    opt = Optimizer(dimensions=self.space, n_initial_points=10, acq_func=&#34;gp_hedge&#34;, acq_optimizer=&#34;auto&#34;)

    best_loss = np.inf
    best_params = None
    best_model = None 

    with tqdm(total=self.n_iter, desc=&#39;Tuning Progress&#39;) as pbar:
        for i in range(self.n_iter):
            suggested_params_list = opt.ask()
            suggested_params_dict = {param.name: value for param, value in zip(self.space, suggested_params_list)}
            loss, model = self.objective(suggested_params_dict, current_step=i+1, total_steps=self.n_iter)
            opt.tell(suggested_params_list, loss)

            if loss &lt; best_loss:
                best_loss = loss
                best_params = suggested_params_list
                best_model = model

            # Print result of each iteration
            pbar.set_postfix({&#39;Iteration&#39;: i+1, &#39;Best Loss&#39;: best_loss})
            pbar.update(1)
    # convert best params to dict 
    best_params_dict = {param.name: value for param, value in zip(self.space, best_params)}
    return best_model, best_params_dict</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="flexynesis.main.LiveLossPlot"><code class="flex name class">
<span>class <span class="ident">LiveLossPlot</span></span>
<span>(</span><span>hyperparams, current_step, total_steps, figsize=(10, 8))</span>
</code></dt>
<dd>
<div class="desc"><p>A callback for visualizing training loss in real-time during hyperparameter optimization.</p>
<p>This class is a PyTorch Lightning callback that plots training loss and other metrics live as the model trains.
It is especially useful for tracking the progress of hyperparameter optimization (HPO) steps.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>hyperparams</code></strong> :&ensp;<code>dict</code></dt>
<dd>Hyperparameters being used in the current HPO step.</dd>
<dt><strong><code>current_step</code></strong> :&ensp;<code>int</code></dt>
<dd>The current step number in the HPO process.</dd>
<dt><strong><code>total_steps</code></strong> :&ensp;<code>int</code></dt>
<dd>The total number of steps in the HPO process.</dd>
<dt><strong><code>figsize</code></strong> :&ensp;<code>tuple</code></dt>
<dd>Size of the figure used for plotting.</dd>
</dl>
<h2 id="methods">Methods</h2>
<p>on_train_start(trainer, pl_module): Initializes the loss tracking at the start of training.
on_train_end(trainer, pl_module): Actions to perform at the end of training.
on_train_epoch_end(trainer, pl_module): Updates and plots the loss after each training epoch.
plot_losses(): Renders the loss plot with the current training metrics.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class LiveLossPlot(Callback):
    &#34;&#34;&#34;
    A callback for visualizing training loss in real-time during hyperparameter optimization.

    This class is a PyTorch Lightning callback that plots training loss and other metrics live as the model trains.
    It is especially useful for tracking the progress of hyperparameter optimization (HPO) steps.

    Attributes:
        hyperparams (dict): Hyperparameters being used in the current HPO step.
        current_step (int): The current step number in the HPO process.
        total_steps (int): The total number of steps in the HPO process.
        figsize (tuple): Size of the figure used for plotting.

    Methods:
        on_train_start(trainer, pl_module): Initializes the loss tracking at the start of training.
        on_train_end(trainer, pl_module): Actions to perform at the end of training.
        on_train_epoch_end(trainer, pl_module): Updates and plots the loss after each training epoch.
        plot_losses(): Renders the loss plot with the current training metrics.
    &#34;&#34;&#34;
    def __init__(self, hyperparams, current_step, total_steps, figsize=(10, 8)):
        super().__init__()
        self.hyperparams = hyperparams
        self.current_step = current_step
        self.total_steps = total_steps
        self.figsize = figsize

    def on_train_start(self, trainer, pl_module):
        self.losses = {}

    def on_train_end(self, trainer, pl_module):
        plt.ioff()

    def on_train_epoch_end(self, trainer, pl_module):
        for key, value in trainer.callback_metrics.items():
            if key not in self.losses:
                self.losses[key] = []
            self.losses[key].append(value.item())
        self.plot_losses()

    def plot_losses(self):
        clear_output(wait=True)
        plt.figure(figsize=self.figsize)
        for key, losses in self.losses.items():
            plt.plot(losses, label=key)
        
        hyperparams_str = &#39;, &#39;.join(f&#34;{key}={value}&#34; for key, value in self.hyperparams.items())
        title = f&#34;HPO Step={self.current_step} out of {self.total_steps}\n({hyperparams_str})&#34;
        
        plt.title(title)
        plt.xlabel(&#34;Epoch&#34;)
        plt.ylabel(&#34;Loss&#34;)
        plt.legend()
        plt.tight_layout()  # Adjust layout so everything fits
        plt.show()</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>pytorch_lightning.callbacks.callback.Callback</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="flexynesis.main.LiveLossPlot.on_train_end"><code class="name flex">
<span>def <span class="ident">on_train_end</span></span>(<span>self, trainer, pl_module)</span>
</code></dt>
<dd>
<div class="desc"><p>Called when the train ends.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def on_train_end(self, trainer, pl_module):
    plt.ioff()</code></pre>
</details>
</dd>
<dt id="flexynesis.main.LiveLossPlot.on_train_epoch_end"><code class="name flex">
<span>def <span class="ident">on_train_epoch_end</span></span>(<span>self, trainer, pl_module)</span>
</code></dt>
<dd>
<div class="desc"><p>Called when the train epoch ends.</p>
<p>To access all batch outputs at the end of the epoch, you can cache step outputs as an attribute of the
:class:<code>pytorch_lightning.core.LightningModule</code> and access them in this hook:</p>
<p>.. code-block:: python</p>
<pre><code>class MyLightningModule(L.LightningModule):
    def __init__(self):
        super().__init__()
        self.training_step_outputs = []

    def training_step(self):
        loss = ...
        self.training_step_outputs.append(loss)
        return loss


class MyCallback(L.Callback):
    def on_train_epoch_end(self, trainer, pl_module):
        # do something with all training_step outputs, for example:
        epoch_mean = torch.stack(pl_module.training_step_outputs).mean()
        pl_module.log("training_epoch_mean", epoch_mean)
        # free up the memory
        pl_module.training_step_outputs.clear()
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def on_train_epoch_end(self, trainer, pl_module):
    for key, value in trainer.callback_metrics.items():
        if key not in self.losses:
            self.losses[key] = []
        self.losses[key].append(value.item())
    self.plot_losses()</code></pre>
</details>
</dd>
<dt id="flexynesis.main.LiveLossPlot.on_train_start"><code class="name flex">
<span>def <span class="ident">on_train_start</span></span>(<span>self, trainer, pl_module)</span>
</code></dt>
<dd>
<div class="desc"><p>Called when the train begins.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def on_train_start(self, trainer, pl_module):
    self.losses = {}</code></pre>
</details>
</dd>
<dt id="flexynesis.main.LiveLossPlot.plot_losses"><code class="name flex">
<span>def <span class="ident">plot_losses</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_losses(self):
    clear_output(wait=True)
    plt.figure(figsize=self.figsize)
    for key, losses in self.losses.items():
        plt.plot(losses, label=key)
    
    hyperparams_str = &#39;, &#39;.join(f&#34;{key}={value}&#34; for key, value in self.hyperparams.items())
    title = f&#34;HPO Step={self.current_step} out of {self.total_steps}\n({hyperparams_str})&#34;
    
    plt.title(title)
    plt.xlabel(&#34;Epoch&#34;)
    plt.ylabel(&#34;Loss&#34;)
    plt.legend()
    plt.tight_layout()  # Adjust layout so everything fits
    plt.show()</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="flexynesis" href="index.html">flexynesis</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="flexynesis.main.HyperparameterTuning" href="#flexynesis.main.HyperparameterTuning">HyperparameterTuning</a></code></h4>
<ul class="">
<li><code><a title="flexynesis.main.HyperparameterTuning.init_early_stopping" href="#flexynesis.main.HyperparameterTuning.init_early_stopping">init_early_stopping</a></code></li>
<li><code><a title="flexynesis.main.HyperparameterTuning.load_and_convert_config" href="#flexynesis.main.HyperparameterTuning.load_and_convert_config">load_and_convert_config</a></code></li>
<li><code><a title="flexynesis.main.HyperparameterTuning.objective" href="#flexynesis.main.HyperparameterTuning.objective">objective</a></code></li>
<li><code><a title="flexynesis.main.HyperparameterTuning.perform_tuning" href="#flexynesis.main.HyperparameterTuning.perform_tuning">perform_tuning</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="flexynesis.main.LiveLossPlot" href="#flexynesis.main.LiveLossPlot">LiveLossPlot</a></code></h4>
<ul class="">
<li><code><a title="flexynesis.main.LiveLossPlot.on_train_end" href="#flexynesis.main.LiveLossPlot.on_train_end">on_train_end</a></code></li>
<li><code><a title="flexynesis.main.LiveLossPlot.on_train_epoch_end" href="#flexynesis.main.LiveLossPlot.on_train_epoch_end">on_train_epoch_end</a></code></li>
<li><code><a title="flexynesis.main.LiveLossPlot.on_train_start" href="#flexynesis.main.LiveLossPlot.on_train_start">on_train_start</a></code></li>
<li><code><a title="flexynesis.main.LiveLossPlot.plot_losses" href="#flexynesis.main.LiveLossPlot.plot_losses">plot_losses</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>