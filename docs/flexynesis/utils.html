<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>flexynesis.utils API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>flexynesis.utils</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import pandas as pd
import numpy as np
import torch

from umap import UMAP
import seaborn as sns
import matplotlib.pyplot as plt
import matplotlib
from sklearn.decomposition import PCA
from sklearn.metrics import balanced_accuracy_score, f1_score, cohen_kappa_score, classification_report
from sklearn.metrics import mean_squared_error, r2_score
from scipy.stats import pearsonr

from sklearn.ensemble import RandomForestClassifier, RandomForestRegressor
from sklearn.svm import SVC, SVR
from sklearn.feature_selection import SelectFromModel
from sklearn.feature_selection import mutual_info_regression, mutual_info_classif
from sklearn.model_selection import KFold, cross_val_score, GridSearchCV

def plot_dim_reduced(matrix, labels, method=&#39;pca&#39;, color_type=&#39;categorical&#39;, scatter_kwargs=None, legend_kwargs=None, figsize=(10, 8)):
    &#34;&#34;&#34;
    Plots the first two dimensions of the transformed input matrix in a 2D scatter plot,
    with points colored based on the provided labels. The transformation method can be either PCA or UMAP.
    
    This function allows users to control several aspects of the plot such as the figure size, scatter plot properties, and legend properties.

    Args:
        matrix (np.array): Input data matrix (n_samples, n_features).
        labels (list): List of labels (strings or integers).
        method (str): Transformation method (&#39;pca&#39; or &#39;umap&#39;). Default is &#39;pca&#39;.
        color_type (str): Type of the color scale (&#39;categorical&#39; or &#39;numerical&#39;). Default is &#39;categorical&#39;.
        scatter_kwargs (dict, optional): Additional keyword arguments for plt.scatter. Default is None.
        legend_kwargs (dict, optional): Additional keyword arguments for plt.legend. Default is None.
        figsize (tuple): Size of the figure (width, height). Default is (10, 8).
    &#34;&#34;&#34;
    
    plt.figure(figsize=figsize)
    
    scatter_kwargs = scatter_kwargs if scatter_kwargs else {}
    legend_kwargs = legend_kwargs if legend_kwargs else {}

    # Compute transformation
    if method.lower() == &#39;pca&#39;:
        transformer = PCA(n_components=2)
    elif method.lower() == &#39;umap&#39;:
        transformer = UMAP(n_components=2)
    else:
        raise ValueError(&#34;Invalid method. Expected &#39;pca&#39; or &#39;umap&#39;&#34;)
        
    transformed_matrix = transformer.fit_transform(matrix)

    # Create a pandas DataFrame for easier plotting
    transformed_df = pd.DataFrame(transformed_matrix, columns=[f&#34;{method.upper()}1&#34;, f&#34;{method.upper()}2&#34;])

    labels = [-1 if pd.isnull(x) or x in {&#39;nan&#39;, &#39;None&#39;} else x for x in labels]

    # Add the labels to the DataFrame
    transformed_df[&#34;Label&#34;] = labels

    if color_type == &#39;categorical&#39;:
        unique_labels = sorted(set(labels))
        colormap = matplotlib.cm.get_cmap(&#34;tab20&#34;, len(unique_labels))
        
        for i, label in enumerate(unique_labels):
            plt.scatter(
                transformed_df[transformed_df[&#34;Label&#34;] == label][f&#34;{method.upper()}1&#34;],
                transformed_df[transformed_df[&#34;Label&#34;] == label][f&#34;{method.upper()}2&#34;],
                color=colormap(i),
                label=label,
                **scatter_kwargs
            )
        if method.lower() == &#39;pca&#39;:
            plt.xlabel(f&#34;PC1 (explained variance: {transformer.explained_variance_ratio_[0]*100:.2f}%)&#34;, fontsize=14)
            plt.ylabel(f&#34;PC2 (explained variance: {transformer.explained_variance_ratio_[1]*100:.2f}%)&#34;, fontsize=14)
        else:
            plt.xlabel(f&#34;{method.upper()} Dimension 1&#34;, fontsize=14)
            plt.ylabel(f&#34;{method.upper()} Dimension 2&#34;, fontsize=14)

        plt.title(f&#34;{method.upper()} Scatter Plot with Colored Labels&#34;, fontsize=18)
        plt.legend(title=&#34;Labels&#34;, **legend_kwargs)
    elif color_type == &#39;numerical&#39;:
        sc = plt.scatter(transformed_df[f&#34;{method.upper()}1&#34;], transformed_df[f&#34;{method.upper()}2&#34;], 
                         c=labels, **scatter_kwargs)
        plt.colorbar(sc, label=&#39;Label&#39;)
    plt.show()


def plot_scatter(true_values, predicted_values):
    &#34;&#34;&#34;
    Plots a scatterplot of true vs predicted values, with a regression line and annotated with the Pearson correlation coefficient.

    Args:
        true_values (list or np.array): True values
        predicted_values (list or np.array): Predicted values
    &#34;&#34;&#34;
    # Convert to numpy arrays (if not already)
    true_values = np.array(true_values)
    predicted_values = np.array(predicted_values)
    
    # Filter out NaN values
    not_nan_indices = ~np.isnan(true_values) &amp; ~np.isnan(predicted_values)
    true_values = true_values[not_nan_indices]
    predicted_values = predicted_values[not_nan_indices]

    # Calculate correlation coefficient
    corr, _ = pearsonr(true_values, predicted_values)
    corr_text = f&#34;Pearson r: {corr:.2f}&#34;
    
    # Generate scatter plot
    plt.scatter(true_values, predicted_values, alpha=0.5)
    
    # Add regression line
    m, b = np.polyfit(true_values, predicted_values, 1)
    plt.plot(true_values, m*true_values + b, color=&#39;red&#39;)
    
    # Add correlation text
    plt.text(min(true_values), max(predicted_values), corr_text, fontsize=12, ha=&#39;left&#39;, va=&#39;top&#39;)
    
    # Add labels and title
    plt.xlabel(&#39;True Values&#39;)
    plt.ylabel(&#39;Predicted Values&#39;)
    plt.title(&#39;True vs Predicted Values&#39;)
    
    plt.show()
    
    
def plot_boxplot(categorical_x, numerical_y, title_x = &#39;Categories&#39;, title_y = &#39;Values&#39;):
    df = pd.DataFrame({title_x: categorical_x, title_y: numerical_y})
    # Create a boxplot
    plt.figure(figsize=(10,6))
    sns.boxplot(x=title_x, y=title_y, data=df, palette=&#39;Set2&#39;)
    plt.show()
    
    
# given a vector of numerical values which may contain 
# NAN values, return a binary grouping based on median values 
def split_by_median(v):
    return ((v - torch.nanmedian(v)) &gt; 0).float()
    
def evaluate_classifier(y_true, y_pred, print_report = False):
    # Balanced accuracy
    balanced_acc = balanced_accuracy_score(y_true, y_pred)
    # F1 score (macro)
    f1 = f1_score(y_true, y_pred, average=&#39;macro&#39;, zero_division=0)
    # Cohen&#39;s Kappa
    kappa = cohen_kappa_score(y_true, y_pred)
    # Full classification report
    if print_report:
        print(&#34;\nClassification Report:&#34;)
        report = classification_report(y_true, y_pred, zero_division=0)
        print(report)
    return {&#34;balanced_acc&#34;: balanced_acc, &#34;f1_score&#34;: f1, &#34;kappa&#34;: kappa}

def evaluate_regressor(y_true, y_pred):
    mse = mean_squared_error(y_true, y_pred)
    r2 = r2_score(y_true, y_pred)
    pearson_corr, _ = pearsonr(y_true, y_pred)
    return {&#34;mse&#34;: mse, &#34;r2&#34;: r2, &#34;pearson_corr&#34;: pearson_corr}

def evaluate_wrapper(y_pred_dict, dataset):
    metrics_list = []
    for var in y_pred_dict.keys():
        ind = ~torch.isnan(dataset.ann[var])
        if dataset.variable_types[var] == &#39;numerical&#39;:
            metrics = evaluate_regressor(dataset.ann[var][ind], y_pred_dict[var][ind].flatten())
        else:
            metrics = evaluate_classifier(dataset.ann[var][ind], y_pred_dict[var][ind])

        for metric, value in metrics.items():
            metrics_list.append({
                &#39;var&#39;: var,
                &#39;variable_type&#39;: dataset.variable_types[var],
                &#39;metric&#39;: metric,
                &#39;value&#39;: value
            })
    # Convert the list of metrics to a DataFrame
    return pd.DataFrame(metrics_list)


def evaluate_baseline_performance(train_dataset, test_dataset, variable_name, n_folds=5, n_jobs = 4):
    def prepare_data(data_object):
        # Concatenate Data Matrices
        X = np.concatenate([tensor for tensor in data_object.dat.values()], axis=1)

        # Prepare Labels
        y = np.array(data_object.ann[variable_name])

        # Filter out samples without a valid label
        valid_indices = ~np.isnan(y)
        X = X[valid_indices]
        y = y[valid_indices]
        return X, y

    # Determine variable type
    variable_type = train_dataset.variable_types[variable_name]

    # Initialize models and parameter grids
    if variable_type == &#39;categorical&#39;:
        model_params = {
            &#39;RandomForestClassifier&#39;: {
                &#39;model&#39;: RandomForestClassifier(random_state=42),
                &#39;params&#39;: {
                    &#39;n_estimators&#39;: [100, 200, 300],
                    &#39;max_depth&#39;: [10, 20, None]
                }
            },
            &#39;SVC&#39;: {
                &#39;model&#39;: SVC(),
                &#39;params&#39;: {
                    &#39;C&#39;: [0.1, 1, 10],
                    &#39;kernel&#39;: [&#39;rbf&#39;, &#39;poly&#39;]
                }
            }
        }
    elif variable_type == &#39;numerical&#39;:
        model_params = {
            &#39;RandomForestRegressor&#39;: {
                &#39;model&#39;: RandomForestRegressor(random_state=42),
                &#39;params&#39;: {
                    &#39;n_estimators&#39;: [100, 200, 300],
                    &#39;max_depth&#39;: [10, 20, None]
                }
            },
            &#39;SVR&#39;: {
                &#39;model&#39;: SVR(),
                &#39;params&#39;: {
                    &#39;C&#39;: [0.1, 1, 10],
                    &#39;kernel&#39;: [&#39;rbf&#39;, &#39;poly&#39;]
                }
            }
        }

    # Cross-Validation and Training
    kf = KFold(n_splits=n_folds, shuffle=True, random_state=42)
    X_train, y_train = prepare_data(train_dataset)
    X_test, y_test = prepare_data(test_dataset)

    metrics_list = []
    for model_name, mp in model_params.items():
        grid_search = GridSearchCV(mp[&#39;model&#39;], mp[&#39;params&#39;], cv=kf, n_jobs=n_jobs)
        grid_search.fit(X_train, y_train)
        best_model = grid_search.best_estimator_

        # Predict on test data
        y_pred = best_model.predict(X_test)

        # Evaluate predictions
        if variable_type == &#39;categorical&#39;:
            metrics = evaluate_classifier(y_test, y_pred)
        elif variable_type == &#39;numerical&#39;:
            metrics = evaluate_regressor(y_test, y_pred)

        for metric, value in metrics.items():
            metrics_list.append({
                &#39;method&#39;: model_name,
                &#39;var&#39;: variable_name,
                &#39;variable_type&#39;: variable_type,
                &#39;metric&#39;: metric,
                &#39;value&#39;: value
            })

    # Convert the list of metrics to a DataFrame
    return pd.DataFrame(metrics_list)


def remove_batch_associated_variables(data, variable_types, target_dict, batch_dict = None, mi_threshold=0.1):
    &#34;&#34;&#34;
    Filter the data matrix to keep only the columns that are predictive of the target variables 
    and not predictive of the batch variables.
    
    Args:
        data (pd.DataFrame): The data matrix.
        target_dict (dict): A dictionary of target variables.
        batch_dict (dict): A dictionary of batch variables.
        variable_types (dict): A dictionary of variable types (either &#34;numerical&#34; or &#34;categorical&#34;).
        mi_threshold (float, optional): The mutual information threshold for a column to be considered predictive.
                                        Defaults to 0.1.
    
    Returns:
        pd.DataFrame: The filtered data matrix.
    &#34;&#34;&#34;
    # Convert target and batch tensors to numpy
    target_dict_np = {k: v.numpy() for k, v in target_dict.items()}

    important_features = set()

    # Find important features for target variables
    for var_name, target in target_dict_np.items():
        # Skip if all values are missing
        if np.all(np.isnan(target)):
            continue
            
        # Subset data and target where target is not missing
        not_missing = ~np.isnan(target)
        data_sub = data[not_missing]
        target_sub = target[not_missing]

        if variable_types[var_name] == &#34;categorical&#34;:
            clf = RandomForestClassifier()
        else:  # numerical
            clf = RandomForestRegressor()
            
        clf = clf.fit(data_sub, target_sub)
        model = SelectFromModel(clf, prefit=True)
        important_features.update(data.columns[model.get_support()])

    if batch_dict is not None:
        batch_dict_np = {k: v.numpy() for k, v in batch_dict.items()}
        # Compute mutual information for batch variables
        for var_name, batch in batch_dict_np.items():
            # Skip if all values are missing
            if np.all(np.isnan(batch)):
                continue

            # Subset data and batch where batch is not missing
            not_missing = ~np.isnan(batch)
            data_sub = data[not_missing]
            batch_sub = batch[not_missing]

            if variable_types[var_name] == &#34;categorical&#34;:
                mi = mutual_info_classif(data_sub, batch_sub)
            else:  # numerical
                mi = mutual_info_regression(data_sub, batch_sub)

            # Remove features with high mutual information with batch variables
            important_features -= set(data.columns[mi &gt; mi_threshold])

    return data[list(important_features)]


def get_important_features(model, var, top=20):
    # Ensure that the variable exists in the model&#39;s feature importances
    if var not in model.feature_importances:
        print(f&#34;No feature importances found for variable: {var}&#34;)
        return None

    # Fetch the dataframe for the specified variable
    df_imp = model.feature_importances[var]

    top_features = df_imp.groupby([&#39;target_class&#39;]).apply(lambda x: x.nlargest(top, &#39;importance&#39;)).reset_index(drop=True)

    return top_features

def subset_assays_by_features(dataset, features_dict):
    # Find indices of the features in the corresponding 
    # data matrix for each key in features_dict
    subset_dat = {}
    for layer in features_dict.keys():
        indices = [dataset.features[layer].get_loc(x) for x in features_dict[layer]]
        subset_dat[layer] = dataset.dat[layer][:, indices]
    # Convert subset_dat to pandas DataFrame and prepend feature names with layer names
    df_list = []
    for layer, data in subset_dat.items():
        # Convert matrix to DataFrame
        df_temp = pd.DataFrame(data)
        
        # Rename columns to prepend with layer name
        df_temp.columns = [f&#34;{layer}_{feature}&#34; for feature in features_dict[layer]]
        df_list.append(df_temp)
    # Concatenate dataframes horizontally
    concatenated_df = pd.concat(df_list, axis=1)
    return concatenated_df    

# Accepts as input a MultiomicDataset object and prints summary stats per variable 
def print_summary_stats(dataset):
    for var, tensor in dataset.ann.items():
        print(f&#34;Summary for variable: {var}&#34;)
        
        if dataset.variable_types[var] == &#34;categorical&#34;:
            # Handle Categorical Variable
            unique_vals, counts = np.unique(tensor, return_counts=True)
            print(&#34;Categorical Variable Summary:&#34;)
            
            for uv, cnt in zip(unique_vals, counts):
                original_label = dataset.label_mappings.get(var, {}).get(uv, uv)  # Fall back to uv if mapping doesn&#39;t exist
                print(f&#34;  Label: {original_label}, Count: {cnt}&#34;)

        elif dataset.variable_types[var] == &#34;numerical&#34;:
            # Handle Numerical Variable
            median_val = np.nanmedian(tensor)
            mean_val = np.nanmean(tensor)
            print(f&#34;Numerical Variable Summary: Median = {median_val}, Mean = {mean_val}&#34;)
        print(&#34;------&#34;)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="flexynesis.utils.evaluate_baseline_performance"><code class="name flex">
<span>def <span class="ident">evaluate_baseline_performance</span></span>(<span>train_dataset, test_dataset, variable_name, n_folds=5, n_jobs=4)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def evaluate_baseline_performance(train_dataset, test_dataset, variable_name, n_folds=5, n_jobs = 4):
    def prepare_data(data_object):
        # Concatenate Data Matrices
        X = np.concatenate([tensor for tensor in data_object.dat.values()], axis=1)

        # Prepare Labels
        y = np.array(data_object.ann[variable_name])

        # Filter out samples without a valid label
        valid_indices = ~np.isnan(y)
        X = X[valid_indices]
        y = y[valid_indices]
        return X, y

    # Determine variable type
    variable_type = train_dataset.variable_types[variable_name]

    # Initialize models and parameter grids
    if variable_type == &#39;categorical&#39;:
        model_params = {
            &#39;RandomForestClassifier&#39;: {
                &#39;model&#39;: RandomForestClassifier(random_state=42),
                &#39;params&#39;: {
                    &#39;n_estimators&#39;: [100, 200, 300],
                    &#39;max_depth&#39;: [10, 20, None]
                }
            },
            &#39;SVC&#39;: {
                &#39;model&#39;: SVC(),
                &#39;params&#39;: {
                    &#39;C&#39;: [0.1, 1, 10],
                    &#39;kernel&#39;: [&#39;rbf&#39;, &#39;poly&#39;]
                }
            }
        }
    elif variable_type == &#39;numerical&#39;:
        model_params = {
            &#39;RandomForestRegressor&#39;: {
                &#39;model&#39;: RandomForestRegressor(random_state=42),
                &#39;params&#39;: {
                    &#39;n_estimators&#39;: [100, 200, 300],
                    &#39;max_depth&#39;: [10, 20, None]
                }
            },
            &#39;SVR&#39;: {
                &#39;model&#39;: SVR(),
                &#39;params&#39;: {
                    &#39;C&#39;: [0.1, 1, 10],
                    &#39;kernel&#39;: [&#39;rbf&#39;, &#39;poly&#39;]
                }
            }
        }

    # Cross-Validation and Training
    kf = KFold(n_splits=n_folds, shuffle=True, random_state=42)
    X_train, y_train = prepare_data(train_dataset)
    X_test, y_test = prepare_data(test_dataset)

    metrics_list = []
    for model_name, mp in model_params.items():
        grid_search = GridSearchCV(mp[&#39;model&#39;], mp[&#39;params&#39;], cv=kf, n_jobs=n_jobs)
        grid_search.fit(X_train, y_train)
        best_model = grid_search.best_estimator_

        # Predict on test data
        y_pred = best_model.predict(X_test)

        # Evaluate predictions
        if variable_type == &#39;categorical&#39;:
            metrics = evaluate_classifier(y_test, y_pred)
        elif variable_type == &#39;numerical&#39;:
            metrics = evaluate_regressor(y_test, y_pred)

        for metric, value in metrics.items():
            metrics_list.append({
                &#39;method&#39;: model_name,
                &#39;var&#39;: variable_name,
                &#39;variable_type&#39;: variable_type,
                &#39;metric&#39;: metric,
                &#39;value&#39;: value
            })

    # Convert the list of metrics to a DataFrame
    return pd.DataFrame(metrics_list)</code></pre>
</details>
</dd>
<dt id="flexynesis.utils.evaluate_classifier"><code class="name flex">
<span>def <span class="ident">evaluate_classifier</span></span>(<span>y_true, y_pred, print_report=False)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def evaluate_classifier(y_true, y_pred, print_report = False):
    # Balanced accuracy
    balanced_acc = balanced_accuracy_score(y_true, y_pred)
    # F1 score (macro)
    f1 = f1_score(y_true, y_pred, average=&#39;macro&#39;, zero_division=0)
    # Cohen&#39;s Kappa
    kappa = cohen_kappa_score(y_true, y_pred)
    # Full classification report
    if print_report:
        print(&#34;\nClassification Report:&#34;)
        report = classification_report(y_true, y_pred, zero_division=0)
        print(report)
    return {&#34;balanced_acc&#34;: balanced_acc, &#34;f1_score&#34;: f1, &#34;kappa&#34;: kappa}</code></pre>
</details>
</dd>
<dt id="flexynesis.utils.evaluate_regressor"><code class="name flex">
<span>def <span class="ident">evaluate_regressor</span></span>(<span>y_true, y_pred)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def evaluate_regressor(y_true, y_pred):
    mse = mean_squared_error(y_true, y_pred)
    r2 = r2_score(y_true, y_pred)
    pearson_corr, _ = pearsonr(y_true, y_pred)
    return {&#34;mse&#34;: mse, &#34;r2&#34;: r2, &#34;pearson_corr&#34;: pearson_corr}</code></pre>
</details>
</dd>
<dt id="flexynesis.utils.evaluate_wrapper"><code class="name flex">
<span>def <span class="ident">evaluate_wrapper</span></span>(<span>y_pred_dict, dataset)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def evaluate_wrapper(y_pred_dict, dataset):
    metrics_list = []
    for var in y_pred_dict.keys():
        ind = ~torch.isnan(dataset.ann[var])
        if dataset.variable_types[var] == &#39;numerical&#39;:
            metrics = evaluate_regressor(dataset.ann[var][ind], y_pred_dict[var][ind].flatten())
        else:
            metrics = evaluate_classifier(dataset.ann[var][ind], y_pred_dict[var][ind])

        for metric, value in metrics.items():
            metrics_list.append({
                &#39;var&#39;: var,
                &#39;variable_type&#39;: dataset.variable_types[var],
                &#39;metric&#39;: metric,
                &#39;value&#39;: value
            })
    # Convert the list of metrics to a DataFrame
    return pd.DataFrame(metrics_list)</code></pre>
</details>
</dd>
<dt id="flexynesis.utils.get_important_features"><code class="name flex">
<span>def <span class="ident">get_important_features</span></span>(<span>model, var, top=20)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_important_features(model, var, top=20):
    # Ensure that the variable exists in the model&#39;s feature importances
    if var not in model.feature_importances:
        print(f&#34;No feature importances found for variable: {var}&#34;)
        return None

    # Fetch the dataframe for the specified variable
    df_imp = model.feature_importances[var]

    top_features = df_imp.groupby([&#39;target_class&#39;]).apply(lambda x: x.nlargest(top, &#39;importance&#39;)).reset_index(drop=True)

    return top_features</code></pre>
</details>
</dd>
<dt id="flexynesis.utils.plot_boxplot"><code class="name flex">
<span>def <span class="ident">plot_boxplot</span></span>(<span>categorical_x, numerical_y, title_x='Categories', title_y='Values')</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_boxplot(categorical_x, numerical_y, title_x = &#39;Categories&#39;, title_y = &#39;Values&#39;):
    df = pd.DataFrame({title_x: categorical_x, title_y: numerical_y})
    # Create a boxplot
    plt.figure(figsize=(10,6))
    sns.boxplot(x=title_x, y=title_y, data=df, palette=&#39;Set2&#39;)
    plt.show()</code></pre>
</details>
</dd>
<dt id="flexynesis.utils.plot_dim_reduced"><code class="name flex">
<span>def <span class="ident">plot_dim_reduced</span></span>(<span>matrix, labels, method='pca', color_type='categorical', scatter_kwargs=None, legend_kwargs=None, figsize=(10, 8))</span>
</code></dt>
<dd>
<div class="desc"><p>Plots the first two dimensions of the transformed input matrix in a 2D scatter plot,
with points colored based on the provided labels. The transformation method can be either PCA or UMAP.</p>
<p>This function allows users to control several aspects of the plot such as the figure size, scatter plot properties, and legend properties.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>matrix</code></strong> :&ensp;<code>np.array</code></dt>
<dd>Input data matrix (n_samples, n_features).</dd>
<dt><strong><code>labels</code></strong> :&ensp;<code>list</code></dt>
<dd>List of labels (strings or integers).</dd>
<dt><strong><code>method</code></strong> :&ensp;<code>str</code></dt>
<dd>Transformation method ('pca' or 'umap'). Default is 'pca'.</dd>
<dt><strong><code>color_type</code></strong> :&ensp;<code>str</code></dt>
<dd>Type of the color scale ('categorical' or 'numerical'). Default is 'categorical'.</dd>
<dt><strong><code>scatter_kwargs</code></strong> :&ensp;<code>dict</code>, optional</dt>
<dd>Additional keyword arguments for plt.scatter. Default is None.</dd>
<dt><strong><code>legend_kwargs</code></strong> :&ensp;<code>dict</code>, optional</dt>
<dd>Additional keyword arguments for plt.legend. Default is None.</dd>
<dt><strong><code>figsize</code></strong> :&ensp;<code>tuple</code></dt>
<dd>Size of the figure (width, height). Default is (10, 8).</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_dim_reduced(matrix, labels, method=&#39;pca&#39;, color_type=&#39;categorical&#39;, scatter_kwargs=None, legend_kwargs=None, figsize=(10, 8)):
    &#34;&#34;&#34;
    Plots the first two dimensions of the transformed input matrix in a 2D scatter plot,
    with points colored based on the provided labels. The transformation method can be either PCA or UMAP.
    
    This function allows users to control several aspects of the plot such as the figure size, scatter plot properties, and legend properties.

    Args:
        matrix (np.array): Input data matrix (n_samples, n_features).
        labels (list): List of labels (strings or integers).
        method (str): Transformation method (&#39;pca&#39; or &#39;umap&#39;). Default is &#39;pca&#39;.
        color_type (str): Type of the color scale (&#39;categorical&#39; or &#39;numerical&#39;). Default is &#39;categorical&#39;.
        scatter_kwargs (dict, optional): Additional keyword arguments for plt.scatter. Default is None.
        legend_kwargs (dict, optional): Additional keyword arguments for plt.legend. Default is None.
        figsize (tuple): Size of the figure (width, height). Default is (10, 8).
    &#34;&#34;&#34;
    
    plt.figure(figsize=figsize)
    
    scatter_kwargs = scatter_kwargs if scatter_kwargs else {}
    legend_kwargs = legend_kwargs if legend_kwargs else {}

    # Compute transformation
    if method.lower() == &#39;pca&#39;:
        transformer = PCA(n_components=2)
    elif method.lower() == &#39;umap&#39;:
        transformer = UMAP(n_components=2)
    else:
        raise ValueError(&#34;Invalid method. Expected &#39;pca&#39; or &#39;umap&#39;&#34;)
        
    transformed_matrix = transformer.fit_transform(matrix)

    # Create a pandas DataFrame for easier plotting
    transformed_df = pd.DataFrame(transformed_matrix, columns=[f&#34;{method.upper()}1&#34;, f&#34;{method.upper()}2&#34;])

    labels = [-1 if pd.isnull(x) or x in {&#39;nan&#39;, &#39;None&#39;} else x for x in labels]

    # Add the labels to the DataFrame
    transformed_df[&#34;Label&#34;] = labels

    if color_type == &#39;categorical&#39;:
        unique_labels = sorted(set(labels))
        colormap = matplotlib.cm.get_cmap(&#34;tab20&#34;, len(unique_labels))
        
        for i, label in enumerate(unique_labels):
            plt.scatter(
                transformed_df[transformed_df[&#34;Label&#34;] == label][f&#34;{method.upper()}1&#34;],
                transformed_df[transformed_df[&#34;Label&#34;] == label][f&#34;{method.upper()}2&#34;],
                color=colormap(i),
                label=label,
                **scatter_kwargs
            )
        if method.lower() == &#39;pca&#39;:
            plt.xlabel(f&#34;PC1 (explained variance: {transformer.explained_variance_ratio_[0]*100:.2f}%)&#34;, fontsize=14)
            plt.ylabel(f&#34;PC2 (explained variance: {transformer.explained_variance_ratio_[1]*100:.2f}%)&#34;, fontsize=14)
        else:
            plt.xlabel(f&#34;{method.upper()} Dimension 1&#34;, fontsize=14)
            plt.ylabel(f&#34;{method.upper()} Dimension 2&#34;, fontsize=14)

        plt.title(f&#34;{method.upper()} Scatter Plot with Colored Labels&#34;, fontsize=18)
        plt.legend(title=&#34;Labels&#34;, **legend_kwargs)
    elif color_type == &#39;numerical&#39;:
        sc = plt.scatter(transformed_df[f&#34;{method.upper()}1&#34;], transformed_df[f&#34;{method.upper()}2&#34;], 
                         c=labels, **scatter_kwargs)
        plt.colorbar(sc, label=&#39;Label&#39;)
    plt.show()</code></pre>
</details>
</dd>
<dt id="flexynesis.utils.plot_scatter"><code class="name flex">
<span>def <span class="ident">plot_scatter</span></span>(<span>true_values, predicted_values)</span>
</code></dt>
<dd>
<div class="desc"><p>Plots a scatterplot of true vs predicted values, with a regression line and annotated with the Pearson correlation coefficient.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>true_values</code></strong> :&ensp;<code>list</code> or <code>np.array</code></dt>
<dd>True values</dd>
<dt><strong><code>predicted_values</code></strong> :&ensp;<code>list</code> or <code>np.array</code></dt>
<dd>Predicted values</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_scatter(true_values, predicted_values):
    &#34;&#34;&#34;
    Plots a scatterplot of true vs predicted values, with a regression line and annotated with the Pearson correlation coefficient.

    Args:
        true_values (list or np.array): True values
        predicted_values (list or np.array): Predicted values
    &#34;&#34;&#34;
    # Convert to numpy arrays (if not already)
    true_values = np.array(true_values)
    predicted_values = np.array(predicted_values)
    
    # Filter out NaN values
    not_nan_indices = ~np.isnan(true_values) &amp; ~np.isnan(predicted_values)
    true_values = true_values[not_nan_indices]
    predicted_values = predicted_values[not_nan_indices]

    # Calculate correlation coefficient
    corr, _ = pearsonr(true_values, predicted_values)
    corr_text = f&#34;Pearson r: {corr:.2f}&#34;
    
    # Generate scatter plot
    plt.scatter(true_values, predicted_values, alpha=0.5)
    
    # Add regression line
    m, b = np.polyfit(true_values, predicted_values, 1)
    plt.plot(true_values, m*true_values + b, color=&#39;red&#39;)
    
    # Add correlation text
    plt.text(min(true_values), max(predicted_values), corr_text, fontsize=12, ha=&#39;left&#39;, va=&#39;top&#39;)
    
    # Add labels and title
    plt.xlabel(&#39;True Values&#39;)
    plt.ylabel(&#39;Predicted Values&#39;)
    plt.title(&#39;True vs Predicted Values&#39;)
    
    plt.show()</code></pre>
</details>
</dd>
<dt id="flexynesis.utils.print_summary_stats"><code class="name flex">
<span>def <span class="ident">print_summary_stats</span></span>(<span>dataset)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def print_summary_stats(dataset):
    for var, tensor in dataset.ann.items():
        print(f&#34;Summary for variable: {var}&#34;)
        
        if dataset.variable_types[var] == &#34;categorical&#34;:
            # Handle Categorical Variable
            unique_vals, counts = np.unique(tensor, return_counts=True)
            print(&#34;Categorical Variable Summary:&#34;)
            
            for uv, cnt in zip(unique_vals, counts):
                original_label = dataset.label_mappings.get(var, {}).get(uv, uv)  # Fall back to uv if mapping doesn&#39;t exist
                print(f&#34;  Label: {original_label}, Count: {cnt}&#34;)

        elif dataset.variable_types[var] == &#34;numerical&#34;:
            # Handle Numerical Variable
            median_val = np.nanmedian(tensor)
            mean_val = np.nanmean(tensor)
            print(f&#34;Numerical Variable Summary: Median = {median_val}, Mean = {mean_val}&#34;)
        print(&#34;------&#34;)</code></pre>
</details>
</dd>
<dt id="flexynesis.utils.remove_batch_associated_variables"><code class="name flex">
<span>def <span class="ident">remove_batch_associated_variables</span></span>(<span>data, variable_types, target_dict, batch_dict=None, mi_threshold=0.1)</span>
</code></dt>
<dd>
<div class="desc"><p>Filter the data matrix to keep only the columns that are predictive of the target variables
and not predictive of the batch variables.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>data</code></strong> :&ensp;<code>pd.DataFrame</code></dt>
<dd>The data matrix.</dd>
<dt><strong><code>target_dict</code></strong> :&ensp;<code>dict</code></dt>
<dd>A dictionary of target variables.</dd>
<dt><strong><code>batch_dict</code></strong> :&ensp;<code>dict</code></dt>
<dd>A dictionary of batch variables.</dd>
<dt><strong><code>variable_types</code></strong> :&ensp;<code>dict</code></dt>
<dd>A dictionary of variable types (either "numerical" or "categorical").</dd>
<dt><strong><code>mi_threshold</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>The mutual information threshold for a column to be considered predictive.
Defaults to 0.1.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>pd.DataFrame</code></dt>
<dd>The filtered data matrix.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def remove_batch_associated_variables(data, variable_types, target_dict, batch_dict = None, mi_threshold=0.1):
    &#34;&#34;&#34;
    Filter the data matrix to keep only the columns that are predictive of the target variables 
    and not predictive of the batch variables.
    
    Args:
        data (pd.DataFrame): The data matrix.
        target_dict (dict): A dictionary of target variables.
        batch_dict (dict): A dictionary of batch variables.
        variable_types (dict): A dictionary of variable types (either &#34;numerical&#34; or &#34;categorical&#34;).
        mi_threshold (float, optional): The mutual information threshold for a column to be considered predictive.
                                        Defaults to 0.1.
    
    Returns:
        pd.DataFrame: The filtered data matrix.
    &#34;&#34;&#34;
    # Convert target and batch tensors to numpy
    target_dict_np = {k: v.numpy() for k, v in target_dict.items()}

    important_features = set()

    # Find important features for target variables
    for var_name, target in target_dict_np.items():
        # Skip if all values are missing
        if np.all(np.isnan(target)):
            continue
            
        # Subset data and target where target is not missing
        not_missing = ~np.isnan(target)
        data_sub = data[not_missing]
        target_sub = target[not_missing]

        if variable_types[var_name] == &#34;categorical&#34;:
            clf = RandomForestClassifier()
        else:  # numerical
            clf = RandomForestRegressor()
            
        clf = clf.fit(data_sub, target_sub)
        model = SelectFromModel(clf, prefit=True)
        important_features.update(data.columns[model.get_support()])

    if batch_dict is not None:
        batch_dict_np = {k: v.numpy() for k, v in batch_dict.items()}
        # Compute mutual information for batch variables
        for var_name, batch in batch_dict_np.items():
            # Skip if all values are missing
            if np.all(np.isnan(batch)):
                continue

            # Subset data and batch where batch is not missing
            not_missing = ~np.isnan(batch)
            data_sub = data[not_missing]
            batch_sub = batch[not_missing]

            if variable_types[var_name] == &#34;categorical&#34;:
                mi = mutual_info_classif(data_sub, batch_sub)
            else:  # numerical
                mi = mutual_info_regression(data_sub, batch_sub)

            # Remove features with high mutual information with batch variables
            important_features -= set(data.columns[mi &gt; mi_threshold])

    return data[list(important_features)]</code></pre>
</details>
</dd>
<dt id="flexynesis.utils.split_by_median"><code class="name flex">
<span>def <span class="ident">split_by_median</span></span>(<span>v)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def split_by_median(v):
    return ((v - torch.nanmedian(v)) &gt; 0).float()</code></pre>
</details>
</dd>
<dt id="flexynesis.utils.subset_assays_by_features"><code class="name flex">
<span>def <span class="ident">subset_assays_by_features</span></span>(<span>dataset, features_dict)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def subset_assays_by_features(dataset, features_dict):
    # Find indices of the features in the corresponding 
    # data matrix for each key in features_dict
    subset_dat = {}
    for layer in features_dict.keys():
        indices = [dataset.features[layer].get_loc(x) for x in features_dict[layer]]
        subset_dat[layer] = dataset.dat[layer][:, indices]
    # Convert subset_dat to pandas DataFrame and prepend feature names with layer names
    df_list = []
    for layer, data in subset_dat.items():
        # Convert matrix to DataFrame
        df_temp = pd.DataFrame(data)
        
        # Rename columns to prepend with layer name
        df_temp.columns = [f&#34;{layer}_{feature}&#34; for feature in features_dict[layer]]
        df_list.append(df_temp)
    # Concatenate dataframes horizontally
    concatenated_df = pd.concat(df_list, axis=1)
    return concatenated_df    </code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="flexynesis" href="index.html">flexynesis</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="flexynesis.utils.evaluate_baseline_performance" href="#flexynesis.utils.evaluate_baseline_performance">evaluate_baseline_performance</a></code></li>
<li><code><a title="flexynesis.utils.evaluate_classifier" href="#flexynesis.utils.evaluate_classifier">evaluate_classifier</a></code></li>
<li><code><a title="flexynesis.utils.evaluate_regressor" href="#flexynesis.utils.evaluate_regressor">evaluate_regressor</a></code></li>
<li><code><a title="flexynesis.utils.evaluate_wrapper" href="#flexynesis.utils.evaluate_wrapper">evaluate_wrapper</a></code></li>
<li><code><a title="flexynesis.utils.get_important_features" href="#flexynesis.utils.get_important_features">get_important_features</a></code></li>
<li><code><a title="flexynesis.utils.plot_boxplot" href="#flexynesis.utils.plot_boxplot">plot_boxplot</a></code></li>
<li><code><a title="flexynesis.utils.plot_dim_reduced" href="#flexynesis.utils.plot_dim_reduced">plot_dim_reduced</a></code></li>
<li><code><a title="flexynesis.utils.plot_scatter" href="#flexynesis.utils.plot_scatter">plot_scatter</a></code></li>
<li><code><a title="flexynesis.utils.print_summary_stats" href="#flexynesis.utils.print_summary_stats">print_summary_stats</a></code></li>
<li><code><a title="flexynesis.utils.remove_batch_associated_variables" href="#flexynesis.utils.remove_batch_associated_variables">remove_batch_associated_variables</a></code></li>
<li><code><a title="flexynesis.utils.split_by_median" href="#flexynesis.utils.split_by_median">split_by_median</a></code></li>
<li><code><a title="flexynesis.utils.subset_assays_by_features" href="#flexynesis.utils.subset_assays_by_features">subset_assays_by_features</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>